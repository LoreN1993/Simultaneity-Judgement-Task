# ==============================
#  START_RUN_PHASE: Esperimento di Simultaneity Judgment
# ==============================

# Importazione delle librerie necessarie
import random
from psychopy import core  # Per gestire il tempo (Clock(), sleep())
import csv  # Per la scrittura dei risultati in file CSV
import os  # Per la gestione dei file e delle cartelle


# ==============================
# 1. FUNZIONE PER SALVARE I DATI
# ==============================

def salva_dati(soa, key, rt, accuracy, isi, jitter, start_time, end_time, block):
    """
    Salva i dati del trial in un file CSV, creando il file se non esiste.
    """
    # Definizione del percorso di salvataggio
    path_to_save = os.path.expanduser('~/Desktop/Lorenzo/Risultati SJ')
    os.makedirs(path_to_save, exist_ok=True)  # Crea la cartella se non esiste

    # Nome del file basato sul numero del soggetto
    subject_nr = var.subject_nr  # Definito in OpenSesame
    file_name = f"subject_{subject_nr}_sj.csv"
    file_path = os.path.join(path_to_save, file_name)

    # Creazione del file se non esiste già
    if not os.path.exists(file_path):
        with open(file_path, mode='w', newline='') as file:
            writer = csv.writer(file)
            writer.writerow(['SOA', 'Response', 'RT (s)', 'Accuracy', 'ISI', 'Jittering', 'Start_time (s)', 'End_time (s)', 'Block'])

    # Formattazione dei dati prima di salvarli
    rt_str = f"{rt:.3f}" if isinstance(rt, (int, float)) else rt
    start_time_str = f"{start_time:.3f}"
    end_time_str = f"{end_time:.3f}"

    # Scrittura dei dati nel file CSV
    with open(file_path, mode='a', newline='') as file:
        writer = csv.writer(file)
        writer.writerow([soa, key, rt_str, accuracy, isi, jitter, start_time_str, end_time_str, block])


# ==============================
# 2. INIZIALIZZAZIONE VARIABILI
# ==============================

# Parametri temporali
isi_medio = 1200  # Interstimulus Interval medio (in ms)
jittering = random.randint(-300, 300)  # Jittering ±300 ms per variabilità
interval_duration = 300  # Intervallo tra croce di fissazione e stimoli (in ms)
sound_duration = 33  # Durata del suono (in ms)

# Creazione dell'orologio per il tempo di reazione (RT)
if trial_counter == 0:
    rt_clock = core.Clock()  # L'orologio viene inizializzato solo all'inizio dell'esperimento

# Incremento del contatore dei trial
trial_counter += 1

# Verifica che il numero di trial non superi il massimo previsto
if trial_counter > total_trials:
    raise ValueError("Il numero di trial supera il totale definito")

# Calcolo dell'ISI variabile
isi_casuale = isi_medio + jittering  

# Pausa prima della presentazione della croce di fissazione
clock.sleep(isi_casuale)


# ==============================
# 3. PRESENTAZIONE DELLA CROCE DI FISSAZIONE
# ==============================

fixation_canvas = canvas(exp)
fixation_canvas.line(sx=0, sy=-30, ex=0, ey=30, penwidth=0.60)  # Linea verticale
fixation_canvas.line(sx=-30, sy=0, ex=30, ey=0, penwidth=0.60)  # Linea orizzontale
fixation_canvas.show()

clock.sleep(700)  # La croce di fissazione dura 700 ms

# Pausa tra fissazione e stimolo
blank_canvas.show()
clock.sleep(interval_duration)  # 300 ms di intervallo


# ==============================
# 4. REGISTRAZIONE DEL TEMPO DI INIZIO
# ==============================

start_time = rt_clock.getTime()  # Registra il tempo in cui inizia il trial


# ==============================
# 5. PRESENTAZIONE DEGLI STIMOLI BASATA SU SOA
# ==============================

soa_clock = core.Clock()  # Orologio per misurare il SOA

if soa < 0:
    print(f"Negative SOA: {soa}")
    soa_clock.reset()  # Reset the clock to measure the SOA duration

    my_sampler.play()  # Play the sound
    clock.sleep(abs(soa))  # Wait for the negative SOA
    soa_duration = soa_clock.getTime() * 1000  # Actual SOA duration in ms
    print(f"Actual negative SOA duration: {soa_duration:.3f} ms")  # Print the SOA duration

    visual_canvas.show()  # Show the visual stimulus
    flip_clock = core.Clock()  # Clock to measure the win.flip() duration
    win.flip()  # Synchronize the stimulus presentation with the monitor's refresh
    flip_duration = flip_clock.getTime() * 1000  # Measure the time taken by the flip
    print(f"Actual win.flip() duration: {flip_duration:.3f} ms")

    stim_duration_clock = core.Clock()  # Clock to measure the visual stimulus duration
    core.wait(2 * (1 / 60.0))  # Wait for 2 refresh cycle (~33.33 ms)
     #blank_canvas.show()  # Remove the visual stimulus - could also remove this
    stim_duration = stim_duration_clock.getTime() * 1000  # Actual visual stimulus duration in ms
    print(f"Actual visual stimulus duration: {stim_duration:.3f} ms")

elif soa > 0:
    print(f"Positive SOA: {soa}")
    visual_canvas.show()  # Show the visual stimulus
    flip_clock = core.Clock()  # Clock to measure the win.flip() duration
    win.flip()  # Synchronize the stimulus presentation with the monitor's refresh
    flip_duration = flip_clock.getTime() * 1000  # Measure the time taken by the flip
    print(f"Actual win.flip() duration: {flip_duration:.3f} ms")

    stim_duration_clock = core.Clock()  # Clock to measure the visual stimulus duration
    core.wait(2 * (1 / 60.0))  # Wait for 2 refresh cycle (~33.33 ms)
    #blank_canvas.show()  # Remove the visual stimulus
    stim_duration = stim_duration_clock.getTime() * 1000  # Actual visual stimulus duration in ms
    print(f"Actual visual stimulus duration: {stim_duration:.3f} ms")

    soa_clock.reset()
    clock.sleep(soa)  # Wait for the positive SOA
    soa_duration = soa_clock.getTime() * 1000  # Actual SOA duration in ms
    print(f"Actual positive SOA duration: {soa_duration:.3f} ms")

    my_sampler.play()  # Play the sound

else:  # SOA = 0
    print("Zero SOA (simultaneous stimuli)")
    soa_clock.reset()

    my_sampler.play()  # Play the sound
    visual_canvas.show()  # Show the visual stimulus simultaneously
    flip_clock = core.Clock()  # Clock to measure the win.flip() duration
    win.flip()  # Synchronize the stimulus presentation with the monitor's refresh
    flip_duration = flip_clock.getTime() * 1000  # Measure the time taken by the flip
    print(f"Actual win.flip() duration: {flip_duration:.3f} ms")

    stim_duration_clock = core.Clock()  # Clock to measure the visual stimulus duration
    core.wait(2 * (1 / 60.0))  # Wait for 2 refresh cycle (~33.33 ms)
    #blank_canvas.show()  # Remove the visual stimulus

    soa_duration = soa_clock.getTime() * 1000  # Actual SOA duration in ms
    stim_duration = stim_duration_clock.getTime() * 1000  # Actual visual stimulus duration in ms
    print(f"Actual simultaneous stimuli duration (SOA=0): {soa_duration:.3f} ms")
    print(f"Actual visual stimulus duration: {stim_duration:.3f} ms")


# ==============================
# 6. RACCOLTA DELLA RISPOSTA
# ==============================

key, rt = my_keyboard.get_key(timeout=2000)  # Attesa della risposta (timeout di 2000 ms)

# Registrazione del tempo di fine trial
end_time = rt_clock.getTime()

# ==============================
# 7. CALCOLO DEL TEMPO DI REAZIONE (RT)
# ==============================

if key is None:
    rt = 'timeout'  # Se il partecipante non risponde in tempo
    accuracy = 0
else:
    rt = end_time - start_time  # RT = tempo di fine - tempo di inizio

    # Determina se la risposta è corretta
    if (-150 <= soa <= 150 and key == 's'):
        accuracy = 1
    elif ((soa < -150 or soa > 150) and key == 'j'):
        accuracy = 1
    else:
        accuracy = 0  # Risposta errata


# ==============================
# 8. SALVATAGGIO DATI
# ==============================

salva_dati(soa, key, rt, accuracy, isi_casuale, jittering, start_time, end_time, block_counter)


# ==============================
# 9. PULIZIA E PAUSA FINALE
# ==============================

blank_canvas.show()
clock.sleep(500)  # Pausa di 500 ms prima del prossimo trial

# END_RUN_PHASE
