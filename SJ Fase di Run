# ==============================
#  START_RUN_PHASE: Esperimento di Simultaneity Judgment
# ==============================

# Importazione delle librerie necessarie
import random
from psychopy import core  # Per gestire il tempo (Clock(), sleep())
import csv  # Per la scrittura dei risultati in file CSV
import os  # Per la gestione dei file e delle cartelle


# ==============================
# 1. FUNZIONE PER SALVARE I DATI
# ==============================

def salva_dati(soa, key, rt, accuracy, isi, jitter, start_time, end_time, block):
    """
    Salva i dati del trial in un file CSV, creando il file se non esiste.
    """
    # Definizione del percorso di salvataggio
    path_to_save = os.path.expanduser('~/Desktop/Lorenzo/Risultati SJ')
    os.makedirs(path_to_save, exist_ok=True)  # Crea la cartella se non esiste

    # Nome del file basato sul numero del soggetto
    subject_nr = var.subject_nr  # Definito in OpenSesame
    file_name = f"subject_{subject_nr}_sj.csv"
    file_path = os.path.join(path_to_save, file_name)

    # Creazione del file se non esiste già
    if not os.path.exists(file_path):
        with open(file_path, mode='w', newline='') as file:
            writer = csv.writer(file)
            writer.writerow(['SOA', 'Response', 'RT (s)', 'Accuracy', 'ISI', 'Jittering', 'Start_time (s)', 'End_time (s)', 'Block'])

    # Formattazione dei dati prima di salvarli
    rt_str = f"{rt:.3f}" if isinstance(rt, (int, float)) else rt
    start_time_str = f"{start_time:.3f}"
    end_time_str = f"{end_time:.3f}"

    # Scrittura dei dati nel file CSV
    with open(file_path, mode='a', newline='') as file:
        writer = csv.writer(file)
        writer.writerow([soa, key, rt_str, accuracy, isi, jitter, start_time_str, end_time_str, block])


# ==============================
# 2. INIZIALIZZAZIONE VARIABILI
# ==============================

# Parametri temporali
isi_medio = 1200  # Interstimulus Interval medio (in ms)
jittering = random.randint(-300, 300)  # Jittering ±300 ms per variabilità
interval_duration = 300  # Intervallo tra croce di fissazione e stimoli (in ms)
sound_duration = 33  # Durata del suono (in ms)

# Creazione dell'orologio per il tempo di reazione (RT)
if trial_counter == 0:
    rt_clock = core.Clock()  # L'orologio viene inizializzato solo all'inizio dell'esperimento

# Incremento del contatore dei trial
trial_counter += 1

# Verifica che il numero di trial non superi il massimo previsto
if trial_counter > total_trials:
    raise ValueError("Il numero di trial supera il totale definito")

# Calcolo dell'ISI variabile
isi_casuale = isi_medio + jittering  

# Pausa prima della presentazione della croce di fissazione
clock.sleep(isi_casuale)


# ==============================
# 3. PRESENTAZIONE DELLA CROCE DI FISSAZIONE
# ==============================

fixation_canvas = canvas(exp)
fixation_canvas.line(sx=0, sy=-30, ex=0, ey=30, penwidth=0.60)  # Linea verticale
fixation_canvas.line(sx=-30, sy=0, ex=30, ey=0, penwidth=0.60)  # Linea orizzontale
fixation_canvas.show()

clock.sleep(700)  # La croce di fissazione dura 700 ms

# Pausa tra fissazione e stimolo
blank_canvas.show()
clock.sleep(interval_duration)  # 300 ms di intervallo


# ==============================
# 4. REGISTRAZIONE DEL TEMPO DI INIZIO
# ==============================

start_time = rt_clock.getTime()  # Registra il tempo in cui inizia il trial


# ==============================
# 5. PRESENTAZIONE DEGLI STIMOLI BASATA SU SOA
# ==============================

soa_clock = core.Clock()  # Orologio per misurare il SOA

if soa < 0:
    # Caso SOA negativo: il suono viene presentato per primo
    my_sampler.play()
    clock.sleep(abs(soa))  # Aspetta la durata del SOA negativo

    # Mostra lo stimolo visivo
    visual_canvas.show()
    flip_clock = core.Clock()  # Orologio per misurare win.flip()
    win.flip()  # Sincronizza la presentazione con il refresh dello schermo
    flip_duration = flip_clock.getTime() * 1000  # Tempo di flip in ms

elif soa > 0:
    # Caso SOA positivo: lo stimolo visivo viene presentato per primo
    visual_canvas.show()
    flip_clock = core.Clock()
    win.flip()
    flip_duration = flip_clock.getTime() * 1000

    clock.sleep(soa)  # Attendi il SOA positivo prima di suonare il beep
    my_sampler.play()

else:
    # Caso SOA = 0: stimoli simultanei
    my_sampler.play()
    visual_canvas.show()
    flip_clock = core.Clock()
    win.flip()
    flip_duration = flip_clock.getTime() * 1000


# ==============================
# 6. RACCOLTA DELLA RISPOSTA
# ==============================

key, rt = my_keyboard.get_key(timeout=2000)  # Attesa della risposta (timeout di 2000 ms)

# Registrazione del tempo di fine trial
end_time = rt_clock.getTime()

# ==============================
# 7. CALCOLO DEL TEMPO DI REAZIONE (RT)
# ==============================

if key is None:
    rt = 'timeout'  # Se il partecipante non risponde in tempo
    accuracy = 0
else:
    rt = end_time - start_time  # RT = tempo di fine - tempo di inizio

    # Determina se la risposta è corretta
    if (-150 <= soa <= 150 and key == 's'):
        accuracy = 1
    elif ((soa < -150 or soa > 150) and key == 'j'):
        accuracy = 1
    else:
        accuracy = 0  # Risposta errata


# ==============================
# 8. SALVATAGGIO DATI
# ==============================

salva_dati(soa, key, rt, accuracy, isi_casuale, jittering, start_time, end_time, block_counter)


# ==============================
# 9. PULIZIA E PAUSA FINALE
# ==============================

blank_canvas.show()
clock.sleep(500)  # Pausa di 500 ms prima del prossimo trial

# END_RUN_PHASE
